from typing import Union, Callable

import torch

Schedule = Callable[[float], float]


def update_learning_rate(optimizer: torch.optim.Optimizer, learning_rate: float) -> None:
    """
    Update the learning rate for a given optimizer.
    Useful when doing linear schedule.

    :param optimizer:
    :param learning_rate:
    """
    for param_group in optimizer.param_groups:
        param_group["lr"] = learning_rate


def linear_schedule(initial_value: Union[float, str]) -> Callable[[float], float]:
    """
    Linear learning rate schedule.

    :param initial_value: (float or str)
    :return: (function)
    """
    if isinstance(initial_value, str):
        initial_value = float(initial_value)

    def func(progress_remaining: float) -> float:
        """
        Progress will decrease from 1 (beginning) to 0
        :param progress_remaining: (float)
        :return: (float)
        """
        return progress_remaining * initial_value

    return func


def get_linear_fn(start: float, end: float, end_fraction: float) -> Schedule:
    """
    Create a function that interpolates linearly between start and end
    between ``progress_remaining`` = 1 and ``progress_remaining`` = ``end_fraction``.
    This is used in DQN for linearly annealing the exploration fraction
    (epsilon for the epsilon-greedy strategy).

    :params start: value to start with if ``progress_remaining`` = 1
    :params end: value to end with if ``progress_remaining`` = 0
    :params end_fraction: fraction of ``progress_remaining``
        where end is reached e.g 0.1 then end is reached after 10%
        of the complete training process.
    :return:
    """

    def func(progress_remaining: float) -> float:
        if (1 - progress_remaining) > end_fraction:
            return end
        else:
            return start + (1 - progress_remaining) * (end - start) / end_fraction

    return func


def constant_fn(val: float) -> Schedule:
    """
    Create a function that returns a constant
    It is useful for learning rate schedule (to avoid code duplication)

    :param val:
    :return:
    """

    def func(_):
        return val

    return func


def get_schedule_fn(parameter):
    if isinstance(parameter, str):
        schedule, initial_value = parameter.split("_")
        initial_value = float(initial_value)
        return linear_schedule(initial_value)
    elif isinstance(parameter, (float, int)):
        # Negative value: ignore (ex: for clipping)
        if parameter < 0:
            raise ValueError(f"Invalid value for {parameter}")
        return constant_fn(float(parameter))
    else:
        raise ValueError(f"Invalid value for {parameter}")


def get_linear_decay_step_fn(start: float, end: float, decay_steps: float) -> Schedule:
    def func(time: float) -> float:
        if time >= decay_steps:
            return end
        else:
            diff = end - start
            return start + diff * (time / decay_steps)

    return func
